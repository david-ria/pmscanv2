#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

// Function to parse CSV
function parseCSV(csvContent) {
  const lines = csvContent.trim().split('\n');
  const headers = lines[0].split(',');
  const rows = [];
  
  for (let i = 1; i < lines.length; i++) {
    const values = lines[i].split(',');
    const row = {};
    headers.forEach((header, index) => {
      row[header.trim()] = values[index] ? values[index].trim() : '';
    });
    rows.push(row);
  }
  
  return rows;
}

// Function to convert CSV row to group config
function csvRowToGroupConfig(row) {
  // Parse pipe-separated values into arrays
  const locations = row.locations ? row.locations.split('|').map(loc => ({
    name: loc.trim(),
    description: `${loc.trim()} location`
  })) : [];
  
  const activities = row.activities ? row.activities.split('|').map(act => ({
    name: act.trim(),
    description: `${act.trim()} activity`
  })) : [];
  
  const events = row.events ? row.events.split('|').map(evt => ({
    name: evt.trim(),
    description: `${evt.trim()} event`
  })) : [];

  return {
    thresholds: {
      pm1_min: parseFloat(row.pm1_min) || 0,
      pm1_max: parseFloat(row.pm1_max) || 15,
      pm25_min: parseFloat(row.pm25_min) || 0,
      pm25_max: parseFloat(row.pm25_max) || 25,
      pm10_min: parseFloat(row.pm10_min) || 0,
      pm10_max: parseFloat(row.pm10_max) || 50
    },
    alarms: {
      enabled: row.alarm_enabled === 'true',
      sound: row.alarm_sound === 'true',
      visual: row.alarm_visual === 'true'
    },
    locations,
    activities,
    events,
    settings: {
      event_notifications: row.event_notifications === 'true',
      location_auto_detect: row.location_auto_detect === 'true',
      activity_auto_suggest: row.activity_auto_suggest === 'true',
      weekly_reports: row.weekly_reports === 'true',
      notification_frequency: row.notification_frequency || 'immediate',
      default_location: row.default_location || '',
      default_activity: row.default_activity || '',
      auto_share_stats: row.auto_share_stats === 'true'
    }
  };
}

// Function to generate TypeScript config file
function generateTypeScriptConfig(groupData) {
  let tsContent = `// Auto-generated group configurations from CSV
// Do not edit this file manually - use the CSV system instead

export interface GroupThreshold {
  pm1_min: number;
  pm1_max: number;
  pm25_min: number;
  pm25_max: number;
  pm10_min: number;
  pm10_max: number;
}

export interface GroupAlarm {
  enabled: boolean;
  sound: boolean;
  visual: boolean;
}

export interface GroupLocation {
  name: string;
  description: string;
}

export interface GroupActivity {
  name: string;
  description: string;
}

export interface GroupEvent {
  name: string;
  description: string;
}

export interface GroupConfig {
  thresholds: GroupThreshold;
  alarms: GroupAlarm;
  locations: GroupLocation[];
  activities: GroupActivity[];
  events: GroupEvent[];
  settings: {
    event_notifications: boolean;
    location_auto_detect: boolean;
    activity_auto_suggest: boolean;
    weekly_reports: boolean;
    notification_frequency: string;
    default_location: string;
    default_activity: string;
    auto_share_stats: boolean;
  };
}

// Group configurations
export const groupConfigs: Record<string, GroupConfig> = {\n`;

  groupData.forEach(group => {
    const config = csvRowToGroupConfig(group);
    tsContent += `  '${group.group_id}': ${JSON.stringify(config, null, 4)},\n`;
  });

  tsContent += `};

// Helper functions
export function getGroupConfig(groupId: string): GroupConfig | null {
  return groupConfigs[groupId] || null;
}

export function getAllGroupIds(): string[] {
  return Object.keys(groupConfigs);
}

export function generateGroupUrl(groupId: string, baseUrl?: string): string {
  const base = baseUrl || window.location.origin;
  return \`\${base}?groupId=\${groupId}\`;
}
`;

  return tsContent;
}

// Function to generate SQL statements
function generateSQL(groupData) {
  let sql = `-- Auto-generated SQL for group creation
-- Review before executing in Supabase

`;

  groupData.forEach(group => {
    const customLocations = group.locations ? group.locations.split('|').map(loc => ({
      name: loc.trim(),
      description: `${loc.trim()} location`
    })) : [];
    
    const customActivities = group.activities ? group.activities.split('|').map(act => ({
      name: act.trim(),
      description: `${act.trim()} activity`
    })) : [];

    sql += `-- Group: ${group.name}
INSERT INTO public.groups (id, name, description, subscription_tier, custom_locations, custom_activities, created_by)
VALUES (
  '${group.group_id}',
  '${group.name}',
  '${group.description || ''}',
  '${group.subscription_tier || 'free'}',
  '${JSON.stringify(customLocations)}',
  '${JSON.stringify(customActivities)}',
  -- Replace with actual user ID: auth.uid()
  (SELECT id FROM auth.users WHERE email = 'your-email@example.com' LIMIT 1)
);

-- Group settings for: ${group.name}
INSERT INTO public.group_settings (
  group_id, 
  pm25_threshold, 
  pm10_threshold, 
  pm1_threshold,
  alarm_enabled,
  event_notifications,
  location_auto_detect,
  activity_auto_suggest,
  weekly_reports,
  notification_frequency,
  default_location,
  default_activity,
  auto_share_stats
) VALUES (
  '${group.group_id}',
  ${parseFloat(group.pm25_max) || 25},
  ${parseFloat(group.pm10_max) || 50},
  ${parseFloat(group.pm1_max) || 15},
  ${group.alarm_enabled === 'true'},
  ${group.event_notifications === 'true'},
  ${group.location_auto_detect === 'true'},
  ${group.activity_auto_suggest === 'true'},
  ${group.weekly_reports === 'true'},
  '${group.notification_frequency || 'immediate'}',
  '${group.default_location || ''}',
  '${group.default_activity || ''}',
  ${group.auto_share_stats === 'true'}
);

`;
  });

  sql += `-- Don't forget to:
-- 1. Replace 'your-email@example.com' with the actual creator's email
-- 2. Add group memberships if needed:
--    INSERT INTO public.group_memberships (group_id, user_id, role) 
--    VALUES ('group-id', 'user-id', 'admin');
`;

  return sql;
}

// Main function
function main() {
  try {
    console.log('üöÄ Starting CSV Group Generator...');
    
    // Read CSV file
    const csvPath = path.join(__dirname, 'groups-config.csv');
    if (!fs.existsSync(csvPath)) {
      console.error('‚ùå groups-config.csv not found. Please create it using the template.');
      process.exit(1);
    }
    
    const csvContent = fs.readFileSync(csvPath, 'utf8');
    const groupData = parseCSV(csvContent);
    
    console.log(`üìä Found ${groupData.length} group(s) to process`);
    
    // Generate TypeScript config
    const tsContent = generateTypeScriptConfig(groupData);
    const tsPath = path.join(__dirname, '..', 'src', 'lib', 'groupConfigs.ts');
    fs.writeFileSync(tsPath, tsContent);
    console.log('‚úÖ Generated src/lib/groupConfigs.ts');
    
    // Generate SQL
    const sqlContent = generateSQL(groupData);
    const sqlPath = path.join(__dirname, 'generated-groups.sql');
    fs.writeFileSync(sqlPath, sqlContent);
    console.log('‚úÖ Generated scripts/generated-groups.sql');
    
    console.log('\nüéâ Generation complete!');
    console.log('\nNext steps:');
    console.log('1. Review the generated TypeScript config');
    console.log('2. Review scripts/generated-groups.sql');
    console.log('3. Execute the SQL in Supabase dashboard if needed');
    console.log('4. Update user emails in the SQL before executing');
    
  } catch (error) {
    console.error('‚ùå Error:', error.message);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  main();
}

module.exports = { parseCSV, csvRowToGroupConfig, generateTypeScriptConfig, generateSQL };